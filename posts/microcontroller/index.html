<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Microcontroller | Roennie123 Blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Die letzten drei Labore handelten von Microcontrollern. Arduinos sind die mitunter bekanntesten Microcontroller, da sie &ldquo;genormt&rdquo; sind. Viele andere Hersteller halten sich an diese Normung. Mikrocontroller werden mit C programmiert (was garnicht so schwer ist wie man zuerst denkt, wenn man noch nie was mit C gemacht hat). Für die optimale Arbeitsumgebung haben wir uns eine Arduino IDE installiert. Darüber lassen sich die passenden Libaries zu den Bauteilen direkt suchen, installieren und einbinden."><meta name=generator content="Hugo 0.108.0"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/sketchingWithHardware/ananke/css/main.min.css><meta property="og:title" content="Microcontroller"><meta property="og:description" content="Die letzten drei Labore handelten von Microcontrollern. Arduinos sind die mitunter bekanntesten Microcontroller, da sie &ldquo;genormt&rdquo; sind. Viele andere Hersteller halten sich an diese Normung. Mikrocontroller werden mit C programmiert (was garnicht so schwer ist wie man zuerst denkt, wenn man noch nie was mit C gemacht hat). Für die optimale Arbeitsumgebung haben wir uns eine Arduino IDE installiert. Darüber lassen sich die passenden Libaries zu den Bauteilen direkt suchen, installieren und einbinden."><meta property="og:type" content="article"><meta property="og:url" content="https://roennie123.github.io/sketchingWithHardware/posts/microcontroller/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-30T17:44:17+01:00"><meta property="article:modified_time" content="2022-11-30T17:44:17+01:00"><meta itemprop=name content="Microcontroller"><meta itemprop=description content="Die letzten drei Labore handelten von Microcontrollern. Arduinos sind die mitunter bekanntesten Microcontroller, da sie &ldquo;genormt&rdquo; sind. Viele andere Hersteller halten sich an diese Normung. Mikrocontroller werden mit C programmiert (was garnicht so schwer ist wie man zuerst denkt, wenn man noch nie was mit C gemacht hat). Für die optimale Arbeitsumgebung haben wir uns eine Arduino IDE installiert. Darüber lassen sich die passenden Libaries zu den Bauteilen direkt suchen, installieren und einbinden."><meta itemprop=datePublished content="2022-11-30T17:44:17+01:00"><meta itemprop=dateModified content="2022-11-30T17:44:17+01:00"><meta itemprop=wordCount content="1307"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Microcontroller"><meta name=twitter:description content="Die letzten drei Labore handelten von Microcontrollern. Arduinos sind die mitunter bekanntesten Microcontroller, da sie &ldquo;genormt&rdquo; sind. Viele andere Hersteller halten sich an diese Normung. Mikrocontroller werden mit C programmiert (was garnicht so schwer ist wie man zuerst denkt, wenn man noch nie was mit C gemacht hat). Für die optimale Arbeitsumgebung haben wir uns eine Arduino IDE installiert. Darüber lassen sich die passenden Libaries zu den Bauteilen direkt suchen, installieren und einbinden."></head><body class="ma0 helvetica bg-moon-gray"><header class="cover bg-top" style=background-image:url(https://roennie123.github.io/sketchingWithHardware/images/signal-2022-12-07-174920_005.jpeg)><div class=bg-black-60><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/sketchingWithHardware/ class="f3 fw2 hover-white no-underline white-90 dib">Roennie123 Blog</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/sketchingWithHardware/about/ title="Abouts page">Abouts</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/sketchingWithHardware/posts/ title="Posts page">Posts</a></li></ul><div class=ananke-socials><a href=https://github.com/Roennie123 target=_blank class="github ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="GitHub link" rel=noopener aria-label="follow on GitHub——Opens in a new window"><span class=icon><svg style="enable-background:new 0 0 512 512" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M256 32C132.3 32 32 134.8 32 261.7c0 101.5 64.2 187.5 153.2 217.9 11.2 2.1 15.3-5 15.3-11.1.0-5.5-.2-19.9-.3-39.1-62.3 13.9-75.5-30.8-75.5-30.8-10.2-26.5-24.9-33.6-24.9-33.6-20.3-14.3 1.5-14 1.5-14 22.5 1.6 34.3 23.7 34.3 23.7 20 35.1 52.4 25 65.2 19.1 2-14.8 7.8-25 14.2-30.7-49.7-5.8-102-25.5-102-113.5.0-25.1 8.7-45.6 23-61.6-2.3-5.8-10-29.2 2.2-60.8.0.0 18.8-6.2 61.6 23.5 17.9-5.1 37-7.6 56.1-7.7 19 .1 38.2 2.6 56.1 7.7 42.8-29.7 61.5-23.5 61.5-23.5 12.2 31.6 4.5 55 2.2 60.8 14.3 16.1 23 36.6 23 61.6.0 88.2-52.4 107.6-102.3 113.3 8 7.1 15.2 21.1 15.2 42.5.0 30.7-.3 55.5-.3 63 0 6.1 4 13.3 15.4 11C415.9 449.1 480 363.1 480 261.7 480 134.8 379.7 32 256 32z"/></svg></span><span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></span></a></div></div></div></nav><div class="tc-l pv6 ph3 ph4-ns"><div class="f2 f1-l fw2 white-90 mb0 lh-title">Microcontroller</div></div></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Microcontroller</h1><time class="f6 mv4 dib tracked" datetime=2022-11-30T17:44:17+01:00>November 30, 2022</time></header><div class="nested-copy-line-height lh-copy helvetica bg-moon-gray f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Die letzten drei Labore handelten von Microcontrollern. Arduinos sind die mitunter bekanntesten Microcontroller, da sie &ldquo;genormt&rdquo; sind. Viele andere Hersteller halten sich an diese Normung. Mikrocontroller werden mit C programmiert (was garnicht so schwer ist wie man zuerst denkt, wenn man noch nie was mit C gemacht hat). Für die optimale Arbeitsumgebung haben wir uns eine Arduino IDE installiert. Darüber lassen sich die passenden Libaries zu den Bauteilen direkt suchen, installieren und einbinden. Ansonsten hat die IDE natürlich auch noch viele weitere Vorteile, auf die ich jetzt aber nicht eingehen möchte.</p><p>Am wichtigsten bei der Verkabelung und Programmierung von Mikrocontrollern ist das Wissen darüber, welcher Pin für was zuständig ist. Ohne dieses Wissen wird vermutlich auch nichts funktionieren. :D Hier ist ein Pinlayout des Arduino Uno R3:
<img src=arduinoUnoR3_pinlayout.jpg alt="Pinlayout Arduino R3">
<a href=https://i.stack.imgur.com/dVkQU.jpg>https://i.stack.imgur.com/dVkQU.jpg</a></p><p>Alle türkisfarbenen Pins sind digitale Anschlussstellen (z.B. für LEDs etc), alle grünen Pins sind analog. Das bedeutet, dass hier Signalvarianzen angeschlossen werden können, wie z.B. Lautsprecher etc. Zusätzlich gibt es noch PWM (pulse width modulation) Pins (rot): das sind &ldquo;semi-analoge&rdquo; Digital-Pins (auf dem Board mit ~ gekennzeichnet).
Die orangenen Pins sind für Bauteile mit serieller Kommunikation wichtig.
Was man auf jeden Fall immer braucht sind die schwarzen Pins mit 5V (oder 3.3V) für die Stromversorgung des Pluspols und GND (ground) für den Minuspol und um den Kreis zu schließen.</p><p>Hauptsächlich haben wir rumprobiert, was wir Cooles mit den gegebenen Bauteilen (Sensoren, Motoren, Displays, LEDs, etc.) machen können. Hier sind meine Versuche:</p><p><strong>Blinkende LEDs (Output)</strong></p><p><img src=signal-2022-12-07-181505.gif alt="blinkende LED"></p><p>Die LED (light-emitting diode) wird über einen Digitalpin angeschlossen. Im Code wird dann der Pin als Output initialisiert. Microcontroller lassen sich am besten über einen Loop programmieren, welchen sie speichern und dann immer wieder abspielen können. Bei der blinkenden LED wird im Loop eine Leuchtdauer definiert und eine Pause. Bei Outputs spricht man die am Pin angeschlossene Hardware mit <strong>digitalWrite(pin, wert)</strong> an. Es folgt ein Codebeispiel wie das für 2 LEDs aussehen könnte:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Shell data-lang=Shell><span style=display:flex><span>void setup<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  pinMode<span style=color:#f92672>(</span>8, OUTPUT<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  pinMode<span style=color:#f92672>(</span>9, OUTPUT<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>void loop<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  digitalWrite<span style=color:#f92672>(</span>8, HIGH<span style=color:#f92672>)</span>;  // turn the LED on <span style=color:#f92672>(</span>HIGH is the voltage level<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  delay<span style=color:#f92672>(</span>100<span style=color:#f92672>)</span>;  
</span></span><span style=display:flex><span>  digitalWrite<span style=color:#f92672>(</span>9, HIGH<span style=color:#f92672>)</span>;  // turn the LED on <span style=color:#f92672>(</span>HIGH is the voltage level<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  digitalWrite<span style=color:#f92672>(</span>8, LOW<span style=color:#f92672>)</span>;   // turn the LED off by making the voltage LOW
</span></span><span style=display:flex><span>  delay<span style=color:#f92672>(</span>100<span style=color:#f92672>)</span>; 
</span></span><span style=display:flex><span>  digitalWrite<span style=color:#f92672>(</span>9, LOW<span style=color:#f92672>)</span>;   // turn the LED off by making the voltage LOW
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p><img src=signal-2022-12-07-181538.gif alt="blinkende LED">
<img src=signal-2022-12-07-181555.gif alt="blinkende LED"></p><p><strong>Taster (Input)</strong></p><p>Hubtaster (Buttons) sind Bauteile um Input zu kommunizieren. Also: das System bemerkt, wenn der Button gedrückt wurde, und reagiert ggf. darauf. Input wird im Cood mit <strong>digitalRead(pin)</strong> ausgelesen.
<img src=signal-2022-12-07-174920_002.jpeg alt="Verkabelung von Pushbutton">
<img src=signal-2022-12-07-174920_003.jpeg alt="Verkabelung von Pushbutton"></p><p>Kombination von Input und Output: wenn das System über den Taster einen Input bekommt (also dieser gedrückt wurde), gibt es einen Output (die LED leuchtet):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Shell data-lang=Shell><span style=display:flex><span>unsigned int button_status <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>void setup<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  pinMode<span style=color:#f92672>(</span>13, INPUT_PULLUP<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  pinMode<span style=color:#f92672>(</span>12, OUTPUT<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>void loop<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  button_status <span style=color:#f92672>=</span> digitalRead<span style=color:#f92672>(</span>13<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span><span style=color:#f92672>(</span>button_status <span style=color:#f92672>==</span> 0<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>    digitalWrite<span style=color:#f92672>(</span>12, HIGH<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    digitalWrite<span style=color:#f92672>(</span>12, LOW<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p><img src=signal-2022-12-07-174920_009.jpeg alt="Verkabelung von Pushbutton"></p><p><strong>LED Matrix (inkl. serielle Kommunikation)</strong></p><p>Eine LED-Matrix sind im Prinzip mehrere LEDs auf einer Platine, welche einzeln angesprochen werden können. Das praktische ist, das man aber nur 5 Pins für den Anschluss braucht (VCC: 5V, GND, DIN, CS: ~, CLK: ~). LED-Matrizen benutzen serielle Kommunikation. Dadurch lassen sich mehrere hintereinander schalten.
<img src=signal-2022-12-07-181619.gif alt="LED Matrix"></p><p>Ich habe zusätzlich noch einen Joystick als Input-Hardware angeschlossen. Bei diesem habe ich dann im Code die x- und y- Koordinaten in oben, unten, rechts und links eingeteilt. Je nachdem welche Richtung entgegengenommen wird, wird der passende Pfeil auf der Matrix angezeigt (leider spiegelverkehrt, da beide Matrizen aufgrund der Kabel nur übereinander aufs Video gepasst haben).
<img src=signal-2022-12-07-174920_012.jpeg alt="Aufbau serielle LED Matrix">
<img src=signal-2022-12-07-181647.gif alt="LED Matrix mit Joystick"></p><p>LED-Bänder benutzen ebenfalls (in der Regel) Protokolle mit serieller Kommunikation (z.B. SPI oder I2C). Mit der passenden Libary kann man dadurch dann auf jede LED einzeln, oder alle zusammen als Output zugreifen. Habe mich selbst an einem LED-Band versucht, aber etwas beim Löten gepfuscht, sodass es einen leichten Wackelkontakt hatte und immer ein paar LEDs ausgelassen wurden.
<img src=signal-2022-12-07-181414_002.jpeg alt="serielle Kommunikation mit LED-Band"></p><p><strong>LCD Bildschirm</strong></p><p>Den kleinen LCD habe ich angeschlossen, und als direkte Ausgabe des Seriel Monitors der Arduino IDE genutzt. Also alles was ich in die IDE eingegeben habe, wurde dann auf dem Display eingeblendet. Dazu braucht man natürlich eine Libary. Eine kleine Schwierigkeit dabei, war das Entfernen des Enter-Zeichens in der Anzeige (um zu kommunizieren dass die Eingabe vollständig ist und angezeigt werden soll wurde Enter gedrückt. Das war dann immer ebenfalls sichtbar auf dem Display). Hat dann aber auch geklappt, indem der Input in einen String (Char-Array) umgewandelt wurde und dann einfach das letzte Zeichen entfernt.
<img src=signal-2022-12-07-181631.gif alt=LCD></p><p><strong>Motoren</strong></p><p>Um auch mit den Motoren warm zu werden habe ich den <strong>Micro Servo 9g</strong> an den Arduino angeschlossen. Zusätzlich noch einen Joystick. Mit dem Joystick sollte man dann die Richtung der Rotorenblattdrehung steuer können. Das hat jedoch nicht komplett geklappt, da die Motordrehung in 0 bis 360 Grad angegeben wird, und irgendein Fehler im Code sie immer wieder springen hat lassen. Denke mit etwas mehr Initiative hätte das auch noch komplett geklappt, wollte dann aber lieber die Zeit dahin investieren, noch mehr Hardware kennenzulernen, statt mich an einer aufzuhängen.
<img src=signal-2022-12-07-174920_008.jpeg alt="Motor mit Joystick"></p><p><strong>Interrupt und Sleep-Modis</strong></p><p>Unterbrechungen der Routine sind super wichtig. Also wenn das und das passiert, halte an und mache das. Da aber die Programmierung von Mikrocontrollern auf sich ständig wiederholenden Loops basiert, ist es sehr schwierig eine manuelle Wartefunktion für einen Interrupt einzubauen. Die Schleife hat ja mehrere &ldquo;Aufträge&rdquo; zu erledigen, und kann erst ab einer bestimmten Stelle im Code dann abfragen ob die Situation für einen Interrupt eingetroffen ist. Das bedeutet es gäbe keine wirkliche &ldquo;Echtzeit&rdquo;-Unterbrechung. Genau aus diesem Grund gibt es bei der Arduinoprogrammierung Interrupts und Sleep-Modis.</p><p>&ldquo;Ein Interrupt ist ein Signal, das die aktuelle Aktivität des Prozessors unterbricht, damit eine andere Funktion ausgeführt werden kann. Die Unterbrechung kann extern, wie zum Beispiel durch das Drücken eines Tasters, oder intern, beispielsweise durch eine Zeituhr oder ein Software-Signal hervorgerufen werden. Einmal aktiviert unterbricht Interrupt die Aktivität des Prozessors und sorgt dafür, dass eine andere Funktion ausgeführt wird. Bekannt ist dies unter dem Namen Unterbrechungsroutine oder ISR, nach der englischen Abkürzung. Sobald die ISR abgeschlossen ist, kehrt das Programm wieder zu seiner vorherigen Aktivität zurück.&rdquo;
(<a href=http://diwo.bq.com/de/interrupts-mit-arduino-benutzen/>http://diwo.bq.com/de/interrupts-mit-arduino-benutzen/</a>)</p><p>Ich habe um Interrupts auszuprobieren einen Taster und eine LED an den Arduino angschlossen. Die LED leuchtet. Wenn der Taster gedrückt wird, wird die Leuchtung der LED unterbrochen:
<img src=signal-2022-12-07-181701.gif alt=interrupt></p><p>Der Code dazu ist relativ einfach: im Setup wird mit <strong>attachInterrupt(interrupt, ISR, mode)</strong> definiert welche Funktion (ISR) aufgerufen wird wenn die Unterbrechung eintritt. Diese habe ich als <strong>interruptMethod()</strong> deklariert. Mit <strong>interrupt</strong> ist die Nummer des Interrupts gemeint, bei welchem man auf einen Input zur Unterbrechung wartet. Bei mir ist das der buttonState welcher mit 0 deklariert ist. Und <strong>mode</strong> ist die Art, wann die ISR (Interrupt Service Routine) einsetzen soll, also was bei der InterruptNr. passieren muss, dass die ISR aufgerufen wird. Bei mir also: wenn der mode LOW bei interrupt 0 passiert wird interruptMethod() aufgerufen.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Shell data-lang=Shell><span style=display:flex><span>const int button <span style=color:#f92672>=</span> 13;
</span></span><span style=display:flex><span>const int led1 <span style=color:#f92672>=</span> 12;
</span></span><span style=display:flex><span>//const int led2 <span style=color:#f92672>=</span> 7;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>volatile int buttonState <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>void setup<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  // put your setup code here, to run once:
</span></span><span style=display:flex><span>  pinMode<span style=color:#f92672>(</span>led1, OUTPUT<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  //pinMode<span style=color:#f92672>(</span>led2, OUTPUT<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  pinMode<span style=color:#f92672>(</span>button, INPUT<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  attachInterrupt<span style=color:#f92672>(</span>0, interruptMethod, LOW<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>void loop<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  // put your main code here, to run repeatedly:
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>void interruptMethod<span style=color:#f92672>(){</span>
</span></span><span style=display:flex><span>  buttonState <span style=color:#f92672>=</span> digitalRead<span style=color:#f92672>(</span>button<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>  digitalWrite<span style=color:#f92672>(</span>led1, buttonState<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p><strong>Schlusswort</strong></p><p>Mein Ziel bezüglich der Mikrocontroller Labs war eigentlich nur, die gängigste Hardware kennenzulernen, benutzen zu können und allgemein einfach was hinzubekommen. Das habe ich meiner Meinung nach geschafft und bin daher sehr zufrieden. :) Natürlich konnte ich nicht alles ausprobieren, und habe auch immer nur maximal 2 Bauteile genutzt. Daher fehlt mir noch das Wissen dazu, wie man bei größeren Projekten mit mehr Hardware verfährt. Ob dann ein Arduino reicht, oder man vllt.sogar mehrere miteinander koppeln kann. Außerdem habe ich nichts wirklich &ldquo;fest&rdquo; verbaut. Aber das kommt noch.
Außerdem habe ich keine Zeit mehr gehabt den WLAN-Chip, Sensoren oder den Buzzer (Summer) auszuprobieren. Habe aber mitbekommen das einige andere in der Laborgruppe ihre Erfahrungen diesbezüglich gemacht haben, und die kann ich sicher dazu befragen wenn ich das Wissen dazu brauche.</p><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-silver bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://roennie123.github.io/sketchingWithHardware/>&copy; Roennie123 Blog 2022</a><div><div class=ananke-socials><a href=https://github.com/Roennie123 target=_blank class="github ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="GitHub link" rel=noopener aria-label="follow on GitHub——Opens in a new window"><span class=icon><svg style="enable-background:new 0 0 512 512" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M256 32C132.3 32 32 134.8 32 261.7c0 101.5 64.2 187.5 153.2 217.9 11.2 2.1 15.3-5 15.3-11.1.0-5.5-.2-19.9-.3-39.1-62.3 13.9-75.5-30.8-75.5-30.8-10.2-26.5-24.9-33.6-24.9-33.6-20.3-14.3 1.5-14 1.5-14 22.5 1.6 34.3 23.7 34.3 23.7 20 35.1 52.4 25 65.2 19.1 2-14.8 7.8-25 14.2-30.7-49.7-5.8-102-25.5-102-113.5.0-25.1 8.7-45.6 23-61.6-2.3-5.8-10-29.2 2.2-60.8.0.0 18.8-6.2 61.6 23.5 17.9-5.1 37-7.6 56.1-7.7 19 .1 38.2 2.6 56.1 7.7 42.8-29.7 61.5-23.5 61.5-23.5 12.2 31.6 4.5 55 2.2 60.8 14.3 16.1 23 36.6 23 61.6.0 88.2-52.4 107.6-102.3 113.3 8 7.1 15.2 21.1 15.2 42.5.0 30.7-.3 55.5-.3 63 0 6.1 4 13.3 15.4 11C415.9 449.1 480 363.1 480 261.7 480 134.8 379.7 32 256 32z"/></svg></span><span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></span></a></div></div></div></footer></body></html>